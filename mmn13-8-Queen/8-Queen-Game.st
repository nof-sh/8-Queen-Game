BorderedMorph subclass: #BoardGUI	instanceVariableNames: 'cellsRowNum matrix boardWidth boardHeight picPath'	classVariableNames: ''	poolDictionaries: ''	category: '8-Queen-Game'!!BoardGUI methodsFor: 'as yet unclassified' stamp: 'NS 3/9/2023 15:25'!checkCells	(1 to: cellsRowNum) do: [:i |		(1 to: cellsRowNum) do: [:j |						(i = cellsRowNum or: (j = cellsRowNum or: (i = 1 or: j = 1)))			ifFalse: [				(matrix at: i at: j) neighbourUp: (matrix at: (i-1) at: j) 							upLeft: (matrix at: (i-1) at: (j-1)) 							upRight: (matrix at: (i-1) at: (j+1)) 							right: (matrix at: i at: (j+1))  							left: (matrix at: i at: (j-1))  							down: (matrix at: (i+1) at: j)  							downLeft: (matrix at: (i+1) at: (j-1))  							downRight: (matrix at: (i+1) at: (j+1)) .				(matrix at: i at: j) nextCell: (matrix at: (i+1) at: j).			]			ifTrue:[				"a cell thats on the border"										"link next cell in the column"				(i = cellsRowNum)				ifTrue: [ (matrix at: i at: j) nextCell: (matrix at: 1 at: j)]				ifFalse: [(matrix at: i at: j) nextCell: (matrix at: (i+1) at: j)].							"link neighbours"				(i = 1 and: j = 1)				ifTrue: [ 									(matrix at: i at: j) neighbourUp: nil 									upLeft: nil 									upRight: nil									right: (matrix at: i at: (j+1))  									left: nil 									down: (matrix at: (i+1) at: j)  									downLeft: nil 									downRight: (matrix at: (i+1) at: (j+1)) .				].				(i = 1 and: j = cellsRowNum)				ifTrue: [ 									(matrix at: i at: j) neighbourUp: nil 									upLeft: nil 									upRight: nil									right: nil 									left: (matrix at: i at: (j-1)) 									down: (matrix at: (i+1) at: j)  									downLeft: (matrix at: (i+1) at: (j-1))  									downRight: nil.				].				(i = cellsRowNum and: j = 1)				ifTrue: [ 									(matrix at: i at: j) neighbourUp: (matrix at: (i-1) at: j) 									upLeft: nil 									upRight: (matrix at: (i-1) at: (j+1)) 									right: (matrix at: i at: (j+1))  									left: nil									down: nil 									downLeft: nil									downRight: nil.				].				(i = cellsRowNum and: j = cellsRowNum)				ifTrue: [ 									(matrix at: i at: j) neighbourUp: (matrix at: (i-1) at: j) 									upLeft: (matrix at: (i-1) at: (j-1)) 									upRight: nil 									right: nil 									left: (matrix at: i at: (j-1))  									down: nil									downLeft: nil									downRight: nil.				].				(i = 1 and: ((j ~= 1) and: (j~=cellsRowNum)))				ifTrue: [ 									(matrix at: i at: j) neighbourUp: nil									upLeft: nil									upRight: nil 									right: (matrix at: i at: (j+1))  									left: (matrix at: i at: (j-1))  									down: (matrix at: (i+1) at: j)  									downLeft: (matrix at: (i+1) at: (j-1))  									downRight: (matrix at: (i+1) at: (j+1)) .				].				(((i ~= 1) and: (i~=cellsRowNum)) and: j = 1)				ifTrue: [ 									(matrix at: i at: j) neighbourUp: (matrix at: (i-1) at: j) 									upLeft: nil									upRight: (matrix at: (i-1) at: (j+1)) 									right: (matrix at: i at: (j+1))  									left: nil									down: (matrix at: (i+1) at: j)  									downLeft: nil									downRight: (matrix at: (i+1) at: (j+1)) .				].				(i = cellsRowNum and: ((j ~= 1) and: (j~=cellsRowNum)))				ifTrue: [ 									(matrix at: i at: j) neighbourUp: (matrix at: (i-1) at: j) 									upLeft: (matrix at: (i-1) at: (j-1)) 									upRight: (matrix at: (i-1) at: (j+1)) 									right: (matrix at: i at: (j+1))  									left: (matrix at: i at: (j-1))  									down: nil  									downLeft: nil 									downRight: nil.				].				(((i ~= 1) and: (i~=cellsRowNum)) and: j = cellsRowNum)				ifTrue: [ 									(matrix at: i at: j) neighbourUp: (matrix at: (i-1) at: j) 									upLeft: (matrix at: (i-1) at: (j-1)) 									upRight: nil									right: nil									left: (matrix at: i at: (j-1))  									down: (matrix at: (i+1) at: j)  									downLeft: (matrix at: (i+1) at: (j-1))  									downRight: nil.				].			]		]		]! !!BoardGUI methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 18:22'!cleanWorld	(1 to: cellsRowNum) do: [:i|		(1 to: cellsRowNum) do: [:j |			(matrix at: i at: j) dellBorder 		]	]! !!BoardGUI methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 15:17'!createCell: i at: j results: boolResults	^ Cell atRow: i column: j cellsRowNum: cellsRowNum picPath: picPath results: boolResults.! !!BoardGUI methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 18:25'!getCellRow: i column: j	^matrix at: i at: j.! !!BoardGUI methodsFor: 'as yet unclassified' stamp: 'NS 3/23/2023 18:53'!initialize: num results: boolResults	| deafultCell newCell rowMorph cellWidth cellHeight |		super initialize.	picPath:= 'c:\\mmn13-8-Queen\\picGame\\'.	cellsRowNum := num.	deafultCell := self createCell: 1 at:1 results: boolResults.	cellWidth := (deafultCell width).	cellHeight := (deafultCell height).	boardWidth := (cellsRowNum) * cellWidth.	boardHeight := (cellsRowNum) * cellHeight .	matrix := Matrix new: (cellsRowNum).		self position: 10@10.	self extent: boardWidth@boardHeight.	self layoutPolicy: TableLayout new.	self listDirection: #bottomToTop. 	self listCentering: #topLeft. 	self wrapCentering: #center. 	self vResizing: #spaceFill.	self hResizing: #spaceFill.	self color: Color black.	self openInWorld.		1 to:(cellsRowNum) do:[ :row |		rowMorph := Morph new layoutPolicy: TableLayout new.		rowMorph listDirection: #rightToLeft.		rowMorph extent: boardWidth@cellHeight.		rowMorph listCentering: #topLeft.		rowMorph wrapCentering: #center.		1 to: (cellsRowNum) do: [ :column |			newCell := self createCell: row at:column results: boolResults.			matrix at: row at: column put: newCell.			rowMorph addMorph: newCell.			].		self addMorph: rowMorph.	].	self	checkCells.! !!BoardGUI methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 18:20'!solution: rowList	1 to: rowList size do: [:j |		(matrix at: (rowList at: j) at: j) displayBorder.	].		World doOneCycle.	5 seconds asDelay wait.		self cleanWorld.! !ImageMorph subclass: #Cell	instanceVariableNames: 'cellHeight cellWidth badCell goodCell next neighbours results picFolder arrow blockCell'	classVariableNames: ''	poolDictionaries: ''	category: '8-Queen-Game'!!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/22/2023 17:56'!badLineDirection: aCell		arrow := (LineMorph from: self center to: aCell center color: Color red width: 2) makeForwardArrow.	arrow openInWorld.	(results)		ifFalse:[			World doOneCycle.			0.5 seconds asDelay wait.		].	arrow delete.	^ self! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 15:30'!blockedCell	^blockCell! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 17:36'!cellClick	(blockCell = 0) 		ifTrue: [blockCell := 1.			self borderColor: badCell.]		ifFalse: [blockCell := 0.			self borderColor: goodCell.].			self borderWidth: 2.	! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:58'!dellBorder	self borderWidth: 0.! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:59'!displayBorder	self borderWidth: 2.	self borderColor: goodCell.! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:59'!displayEmptyCell	^ self subclassResponsibility.! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:59'!displayQueen	^ self subclassResponsibility.! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:58'!height	^cellHeight.! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 18:44'!initialize: picPath results: boolResults	super initialize.		cellWidth :=50.	cellHeight :=50.	badCell := Color red.	goodCell := Color gray.	blockCell := 0.		self width: cellWidth.	self height: cellHeight.	self vResizing: #spaceFill.	self hResizing: #spaceFill.	self on: #click send: #cellClick to: self.		results := boolResults.	picFolder := picPath.! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 16:06'!neighbourUp: upCell upLeft: upLeftCell upRight: upRightCell right: rightCell left: leftCell down: downCell downLeft: downLeftCell downRight: downRightCell	neighbours := Dictionary newFrom: {		#up->upCell. 		#ul->upLeftCell.		#ur->upRightCell.		#right -> rightCell.		#left -> leftCell.		#down -> downCell.		#dl -> downLeftCell.		#dr -> downRightCell.	}! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/22/2023 19:58'!nextCell		(next blockedCell = 1)	ifTrue: [^(next nextCell)]	ifFalse: [^next].	! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/22/2023 19:22'!nextCell: aCell	next:= aCell	! !!Cell methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:57'!width	^cellWidth.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cell class	instanceVariableNames: 'cellWidth cellHeight'!!Cell class methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 15:16'!atRow: i column: j cellsRowNum: num picPath: aPath results: boolResults	| index |	index := (i * num) + j.	(		(			(i rem:2) =0 and: (index rem: 2) = 0		)		 or: 		( 			(i rem:2) =1 and: (index rem: 2) = 1		)	)	ifTrue: [^ BlackCell new initialize: aPath results: boolResults]	ifFalse: [^ WhiteCell new initialize: aPath results: boolResults].! !Cell subclass: #BlackCell	instanceVariableNames: 'emptyPic queenPic'	classVariableNames: ''	poolDictionaries: ''	category: '8-Queen-Game'!!BlackCell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 17:13'!displayEmptyCell	self image: (ImageReadWriter formFromFileNamed: emptyPic).	! !!BlackCell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 17:12'!displayQueen	self image: (ImageReadWriter formFromFileNamed: queenPic).	! !!BlackCell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 18:51'!initialize: aPath results: boolResults 	super initialize: aPath results: boolResults.		emptyPic := picFolder , 'blackEmpty.bmp'.	queenPic := picFolder , 'blackQueen.bmp'.				self	displayEmptyCell! !Object subclass: #Queen	instanceVariableNames: 'row column neighbours cell lastQueen boardG'	classVariableNames: ''	poolDictionaries: ''	category: '8-Queen-Game'!!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/22/2023 19:33'!advance	row = 8 ifTrue:[neighbours nextSolution				ifFalse:[^ false].			row :=0.			].	row := row +1.		self notToDisplay.	self nextCell.	self displayCellQueen.		^ true! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/22/2023 18:19'!canAttack: aQueen inRow: aRow inCell: aColumn	| columnSub direction|		columnSub := aColumn - column.		((row = aRow	or:[row + columnSub = aRow])	or:[row - columnSub = aRow])	ifTrue:[		(row = aRow)		ifTrue: [			(column < aColumn)			ifTrue: [				direction := #right.			]			ifFalse: [				direction := #left.			]		].		(row + columnSub = aRow)		ifTrue: [			(column < aColumn)			ifTrue: [				direction := #dr.						]			ifFalse: [				direction := #dl.				]		].		(row - columnSub = aRow)		ifTrue: [			(column < aColumn)			ifTrue: [					direction := #ur.							]			ifFalse: [				direction := #ul.				]		].				cell badLineDirection: aQueen getCell.		^ true	].		^ neighbours canAttack: aQueen inRow: aRow inCell: aColumn! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/9/2023 16:03'!displayCellQueen	cell displayQueen.! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/9/2023 16:09'!firstSolution	neighbours firstSolution.	row := 1.	^ self nextOptionAttackRow! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/20/2023 21:23'!getCell	^cell! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/23/2023 18:51'!initialize: num results: boolResults		boardG := BoardGUI new initialize: num results: boolResults.	lastQueen := QueenTerm new.	(1 to: num) do:[:i | 		lastQueen := Queen new setColumn: i andNeighbor: lastQueen; setCell: (boardG getCellRow: 1 column: i); displayCellQueen	]! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 18:30'!isQueenTerm	^false! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 19:12'!nextCell	cell := cell nextCell.! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/22/2023 17:20'!nextOptionAttackRow		[neighbours canAttack: self inRow: row inCell: column]	whileTrue:[self advance ifFalse:[^ false]].		^ true! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:13'!nextSolution		^ self advance	and:[self nextOptionAttackRow]! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 20:40'!notToDisplay	cell displayEmptyCell.! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 19:22'!result	^ neighbours result add: row; yourself! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:25'!setCell: aCell	cell := aCell.! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:11'!setColumn: col andNeighbor: queenNeighbour		column := col.	neighbours := queenNeighbour.! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 20:39'!solution	cell displayBorder.! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/23/2023 18:50'!solve	| solution |	Transcript clear.	lastQueen firstSolution ifTrue:[		solution := lastQueen result.		Transcript show: solution printString; cr.		boardG solution: solution.			[lastQueen nextSolution] whileTrue:[			solution := lastQueen result.			Transcript show: solution printString; cr.			boardG solution: solution.		].			Transcript show: 'End of game!!!!!!'; cr.	]	ifFalse:[Transcript show: 'game faild - solution does not found.'; cr]! !!Queen methodsFor: 'as yet unclassified' stamp: 'NS 3/23/2023 18:50'!start	self initialize:8 results: false.	self solve.! !Queen subclass: #QueenTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '8-Queen-Game'!!QueenTerm methodsFor: 'as yet unclassified' stamp: 'NS 3/22/2023 17:43'!canAttack: aQueen inRow: aRow inCell: aColumn	^ false! !!QueenTerm methodsFor: 'as yet unclassified' stamp: 'NS 3/9/2023 16:09'!firstSolution	^ true! !!QueenTerm methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 18:30'!isQueenTerm	^true! !!QueenTerm methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:08'!nextSolution	^ false! !!QueenTerm methodsFor: 'as yet unclassified' stamp: 'NS 3/8/2023 15:08'!result	^ OrderedCollection new! !Cell subclass: #WhiteCell	instanceVariableNames: 'emptyPic queenPic'	classVariableNames: ''	poolDictionaries: ''	category: '8-Queen-Game'!!WhiteCell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 17:13'!displayEmptyCell	self image: (ImageReadWriter formFromFileNamed: emptyPic).	! !!WhiteCell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 17:13'!displayQueen	self image: (ImageReadWriter formFromFileNamed: queenPic).	! !!WhiteCell methodsFor: 'as yet unclassified' stamp: 'NS 3/21/2023 18:51'!initialize: aPath results: boolResults 	super initialize: aPath results: boolResults.		emptyPic := picFolder , 'whiteEmpty.bmp'.	queenPic := picFolder , 'whiteQueen.bmp'.				self	displayEmptyCell.! !